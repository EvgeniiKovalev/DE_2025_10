input { 
  file {
    path => "/app/weblog.csv"
    start_position => "beginning"
    sincedb_path => "/dev/null"
  }
}

filter {
    if [message] =~ /^chmod/ or [message] =~ /^rm/ or [message] !~ /^\d+\./ {
      #drop { }
      mutate { add_tag => ["garbage_data"] }
    }
    if "garbage_data" not in [tags] {
        csv {
          columns => ["Ip", "Dt", "Request", "Status"]
          separator => ","
        }
        mutate {
          gsub => [ "Dt", "^\[", "" ]
          strip => ["Status"]
          convert => { "Status" => "integer" }
        }
        date {
          match => ["Dt", "dd/MMM/yyyy:HH:mm:ss"]
          target => "@timestamp"
          timezone => "UTC"
        }
        grok {
          match => { "Request" => "%{WORD:Method_http} %{URIPATHPARAM:Uri} %{NOTSPACE:Http_version}"}
        }
        mutate {
          convert => { "Status" => "integer" }
          remove_field => [ "path", "host", "Dt", "message", "@version", "Request" ]
        }
    }
}

output {
    if "garbage_data" in [tags] {
      elasticsearch {
        hosts => "elasticsearch"
        index => "invalid-logs-%{+YYYY.MM}" # + означает взять значение из поля @timestamp и отформатировать его как дату
      }
    } else {
        elasticsearch {
          hosts => "elasticsearch"
          index => "weblogs-%{+YYYY.MM}"
        }
    }
    stdout { codec => rubydebug }
}